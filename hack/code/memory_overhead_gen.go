/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"sort"
	"sync"
	"time"

	"github.com/avast/retry-go"
	"github.com/samber/lo"
	"go.uber.org/zap"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/util/workqueue"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	"github.com/aws/karpenter-core/pkg/apis/v1alpha5"
	coreoperator "github.com/aws/karpenter-core/pkg/operator"
	"github.com/aws/karpenter-core/pkg/operator/scheme"
	"github.com/aws/karpenter-core/pkg/utils/resources"
	"github.com/aws/karpenter/pkg/apis/settings"
	"github.com/aws/karpenter/pkg/apis/v1alpha1"
	"github.com/aws/karpenter/pkg/cloudprovider"
	"github.com/aws/karpenter/pkg/operator"
)

var pollingOptions = []retry.Option{
	retry.Attempts(100), // This whole poll should take ~500s
	retry.Delay(time.Second * 5),
	retry.DelayType(retry.FixedDelay),
	retry.LastErrorOnly(true),
}

var outFile string
var clusterName string

func init() {
	flag.StringVar(&clusterName, "cluster-name", "", "cluster name to use when passing subnets into GetInstanceTypes()")
	flag.StringVar(&outFile, "out-file", "zz_generated.memory_overhead.go", "file to output the generated data")
	flag.Parse()
}

type InstanceTypeCapacityData struct {
	Name      string
	Estimated v1.ResourceList
	Actual    v1.ResourceList
}

const fileFormat = `
//go:build !ignore_autogenerated

%s
package instance

// GENERATED FILE. DO NOT EDIT DIRECTLY.
// Update hack/code/memory_overhead_gen.go and re-generate to edit

var (
	memoryOverheadBytes = map[string]int64{
		%s
	}
)
`

func main() {
	logger := lo.Must(zap.NewProduction()).Sugar()
	if clusterName == "" {
		log.Fatalf("cluster name cannot be empty")
	}
	restConfig := config.GetConfigOrDie()
	kubeClient := lo.Must(client.New(restConfig, client.Options{Scheme: scheme.Scheme}))
	ctx := context.Background()
	ctx = settings.ToContext(ctx, &settings.Settings{ClusterName: clusterName, IsolatedVPC: true, VMMemoryOverheadPercent: 0})

	nodeTemplate := &v1alpha1.AWSNodeTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name: "default",
		},
		Spec: v1alpha1.AWSNodeTemplateSpec{
			AWS: v1alpha1.AWS{
				AMIFamily:             &v1alpha1.AMIFamilyBottlerocket,
				SecurityGroupSelector: map[string]string{"karpenter.sh/discovery": clusterName},
				SubnetSelector:        map[string]string{"karpenter.sh/discovery": clusterName},
			},
		},
	}
	lo.Must0(kubeClient.Create(ctx, nodeTemplate))
	defer func() {
		lo.Must0(kubeClient.Delete(ctx, nodeTemplate))
	}()

	ctx, op := operator.NewOperator(ctx, &coreoperator.Operator{
		Manager:             lo.Must(manager.New(restConfig, manager.Options{})),
		KubernetesInterface: kubernetes.NewForConfigOrDie(restConfig),
	})
	cloudProvider := cloudprovider.New(
		op.InstanceTypesProvider,
		op.InstanceProvider,
		kubeClient,
		op.AMIProvider,
		op.SecurityGroupProvider,
		op.SubnetProvider,
	)
	instanceTypes := lo.Must(cloudProvider.GetInstanceTypes(ctx, &v1alpha5.Provisioner{
		Spec: v1alpha5.ProvisionerSpec{
			ProviderRef: &v1alpha5.MachineTemplateRef{
				Name: nodeTemplate.Name,
			},
		},
	}))

	mu := sync.Mutex{}
	var data []InstanceTypeCapacityData
	workqueue.ParallelizeUntil(ctx, 100, len(instanceTypes), func(i int) {
		machine := &v1alpha5.Machine{
			ObjectMeta: metav1.ObjectMeta{
				GenerateName: "default-",
			},
			Spec: v1alpha5.MachineSpec{
				Requirements: []v1.NodeSelectorRequirement{
					{
						Key:      v1.LabelInstanceTypeStable,
						Operator: v1.NodeSelectorOpIn,
						Values:   []string{instanceTypes[i].Name},
					},
					{
						Key:      v1alpha5.LabelCapacityType,
						Operator: v1.NodeSelectorOpIn,
						Values:   []string{v1alpha5.CapacityTypeOnDemand},
					},
				},
				MachineTemplateRef: &v1alpha5.MachineTemplateRef{
					Name: nodeTemplate.Name,
				},
			},
		}
		if err := kubeClient.Create(ctx, machine); err != nil {
			logger.With("instance-type", instanceTypes[i].Name, "machine", machine.Name).Error(err)
			return
		}
		logger.With("instance-type", instanceTypes[i].Name, "machine", machine.Name).Infof("creating machine for instance type")
		// Wait until the corresponding node registers and reports its allocatable
		node := &v1.Node{}
		if err := retry.Do(func() error {
			m := &v1alpha5.Machine{}
			if err := kubeClient.Get(ctx, client.ObjectKeyFromObject(machine), m); err != nil {
				if errors.IsNotFound(err) {
					return retry.Unrecoverable(err)
				}
				return err
			}
			if m.Status.NodeName == "" {
				return fmt.Errorf("node status hasn't populated")
			}
			if err := kubeClient.Get(ctx, types.NamespacedName{Name: m.Status.NodeName}, node); err != nil {
				return err
			}
			if node.Status.Allocatable == nil {
				return fmt.Errorf("node allocatable details haven't populated yet")
			}
			return nil
		}, pollingOptions...); err != nil {
			logger.With("instance-type", instanceTypes[i].Name, "machine", machine.Name).Error(err)
			return
		}
		logger.With("instance-type", instanceTypes[i].Name, "machine", machine.Name, "capacity", node.Status.Capacity).Infof("retrieved capacity information for instance")
		mu.Lock()
		data = append(data, InstanceTypeCapacityData{
			Name:      instanceTypes[i].Name,
			Estimated: instanceTypes[i].Capacity,
			Actual:    node.Status.Capacity,
		})
		mu.Unlock()
		if err := kubeClient.Delete(ctx, machine); err != nil {
			logger.With("instance-type", instanceTypes[i].Name, "machine", machine.Name).Error(err)
		}
	})

	// Sort the data so it has a consistent ordering
	sort.Slice(data, func(i, j int) bool {
		return data[i].Name < data[j].Name
	})

	src := &bytes.Buffer{}
	for _, d := range data {
		diff := resources.Subtract(d.Estimated, d.Actual)
		src.WriteString(fmt.Sprintf("\"%s\": %d,\n", d.Name, diff.Memory().Value()))
	}

	// Format and print to the file
	license := lo.Must(os.ReadFile("hack/boilerplate.go.txt"))
	formatted := lo.Must(format.Source([]byte(fmt.Sprintf(fileFormat, license, src.String()))))
	lo.Must0(os.WriteFile(outFile, formatted, 0644))
}
